{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Reto's toolbox","text":"<p>Here is the documentation for Reto's toolbox. Well, this is most likely for myself and thus mostly consists of an automatically generated API documentation.</p> <p>On the right-hand side you can find the available tools. </p>"},{"location":"#installation","title":"Installation","text":"<p>To install the tools into your environment,  you should install from <code>git</code>.</p> <pre><code>pip install git+https://github.com/trappitsch/rttools.git\n</code></pre>"},{"location":"#units","title":"Units","text":"<p>Note that <code>pint</code>  is used to provide unitful quantities to certain routiens. These are indicated by the <code>Quantity</code> annotation.</p> <p>To use units, the following gives an example:</p> <pre><code>from rttools import ureg  # the unit registry\n\nvoltage = 3 * ureg.V\ncurrent = 1.5 * ureg.A\n\nresistance = voltage / current\n</code></pre> <p>In this example, <code>resistance</code> will now be unitful. This is very helpful for avoiding unit conversion mistakes!</p> <p>Unitful array-like objects</p> <p>To create unitful array-like objects,  please assign a unit to the whole array and NOT to the individual arrays.</p> <pre><code>import numpy as np\n\nfrom rttools import ureg\n\ncurrents = np.array([1.2, 3.5, 17.9]) * ureg.A\n</code></pre>"},{"location":"latex/","title":"LaTeX tools","text":"<p>Tools for LaTeX formatting</p> <p>This module contains functions for formatting numbers, isotopes, etc. It can be imported as <code>ltx</code> as following:</p> <pre><code>from rttools import latex\n</code></pre>"},{"location":"latex/#rttools.latex.delta_iso","title":"<code>delta_iso(iso1, iso2, full=False)</code>","text":"<p>Return LaTeX formatted string for delta notation of two isotopes.</p> <p>Full label is, e.g., d(30Si/28Si). Short version is d30Si28.</p> <p>Note: For short version (default) of the return it is assumed that all the     both elements are the same.</p> <p>Parameters:</p> Name Type Description Default <code>iso1</code> <code>str</code> <p>Nominator isotope, e.g., \"Si-30\"</p> required <code>iso2</code> <code>str</code> <p>Denominator isotope, e.g., \"Si-28\"</p> required <code>full</code> <p>Do you want a full label? Otherwise, short version used.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>LaTeX formatted label for delta value. Unit not included.</p> Source code in <code>src/rttools/latex.py</code> <pre><code>def delta_iso(iso1: str, iso2: str, full=False) -&gt; str:\n    \"\"\"Return LaTeX formatted string for delta notation of two isotopes.\n\n    Full label is, e.g., d(30Si/28Si). Short version is d30Si28.\n\n    Note: For short version (default) of the return it is assumed that all the\n        both elements are the same.\n\n    :param iso1: Nominator isotope, e.g., \"Si-30\"\n    :type iso1: str\n    :param iso2: Denominator isotope, e.g., \"Si-28\"\n    :type iso2: str\n    :param full: Do you want a full label? Otherwise, short version used.\n\n    :return: LaTeX formatted label for delta value. Unit not included.\n    :rtype: str\n    \"\"\"\n    iso1 = ini.iso[iso1].name\n    iso2 = ini.iso[iso2].name\n    ele1, aa1 = split_iso(iso1)\n    ele2, aa2 = split_iso(iso2)\n    if full:\n        ret_val = (\n            f\"$\\\\delta({{^{{{aa1}}}}}\\\\mathrm{{{ele1}}}\"\n            f\"/{{^{{{aa2}}}}}\\\\mathrm{{{ele2}}})$ (\u2030)\"\n        )\n    else:\n        ret_val = f\"$\\\\delta{{^{{{aa1}}}}}\\\\mathrm{{{ele1}}}_{{{aa2}}}$ (\u2030)\"\n    return ret_val\n</code></pre>"},{"location":"latex/#rttools.latex.error_formatting","title":"<code>error_formatting(value, unc, prec)</code>","text":"<p>Take a value and its uncertainty and express is as a formatted LaTeX string.</p> <p>Scientific notation is assumed. As an example, if value is 0.0002153 and uncertainty is 0.00002, at a precision of 3 the formatted string would be: \\((2.15 \\pm 0.20) \\times 10^{-4}\\)</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Value to be given</p> required <code>unc</code> <code>float</code> <p>Uncertainty of the value</p> required <code>prec</code> <code>int</code> <p>Significant digits.</p> required <p>Returns:</p> Type Description <code>str</code> <p>LaTeX formatted string, see example above.</p> Source code in <code>src/rttools/latex.py</code> <pre><code>def error_formatting(value: float, unc: float, prec: int) -&gt; str:\n    \"\"\"Take a value and its uncertainty and express is as a formatted LaTeX string.\n\n    Scientific notation is assumed. As an example, if value is 0.0002153 and uncertainty\n    is 0.00002, at a precision of 3 the formatted string would be:\n    $(2.15 \\\\pm 0.20) \\\\times 10^{-4}$\n\n    :param value: Value to be given\n    :param unc: Uncertainty of the value\n    :param prec: Significant digits.\n\n    :return: LaTeX formatted string, see example above.\n    \"\"\"\n    value_exp_not = f\"{value:E}\"\n    exponent = int(value_exp_not.split(\"E\")[1])\n    value_str = f\"{value*10**(-exponent):.{prec}f}\"\n    unc_str = f\"{unc*10**(-exponent):.{prec}f}\"\n    if exponent != 0:\n        ret_str = f\"$({value_str} \\\\pm {unc_str}) \\\\times 10^{{{exponent}}}$\"\n    else:\n        ret_str = f\"${value_str} \\\\pm {unc_str}$\"\n    return ret_str\n</code></pre>"},{"location":"latex/#rttools.latex.exp_notation","title":"<code>exp_notation(num, prec=2)</code>","text":"<p>Take a number and return it in LaTeX exponential notation.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>float</code> <p>Number itself.</p> required <code>prec</code> <code>int</code> <p>Precision.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>LaTeX formatted string.</p> Source code in <code>src/rttools/latex.py</code> <pre><code>def exp_notation(num: float, prec: int = 2) -&gt; str:\n    \"\"\"Take a number and return it in LaTeX exponential notation.\n\n    :param num: Number itself.\n    :param prec: Precision.\n\n    :return: LaTeX formatted string.\n    \"\"\"\n    num_str = f\"{num:.{prec}E}\"\n    e_index = num_str.find(\"E\")\n    value_str = decimal.Decimal(num_str[:e_index]).normalize()\n    zeros_required = prec - len(str(value_str).split(\".\")[1])  # might be cut off!\n    exp_str = decimal.Decimal(num_str[e_index + 1 :]).normalize()\n    ret_str = f\"${value_str}{'0'*zeros_required} \\\\times 10^{{{exp_str}}}$\"\n    return ret_str\n</code></pre>"},{"location":"latex/#rttools.latex.iso_transformer","title":"<code>iso_transformer(iso)</code>","text":"<p>Transform isotope from <code>46Ti</code> notation to <code>Ti-46</code> notation and vice verse.</p> <p>Transformation direction is automatically determined by input.</p> <p>Parameters:</p> Name Type Description Default <code>iso</code> <code>str</code> <p>Isotope as string</p> required <p>Returns:</p> Type Description <p>iso, but in transformed notation</p> Source code in <code>src/rttools/latex.py</code> <pre><code>def iso_transformer(iso: str):\n    \"\"\"Transform isotope from `46Ti` notation to `Ti-46` notation and vice verse.\n\n    Transformation direction is automatically determined by input.\n\n    :param iso: Isotope as string\n\n    :return: iso, but in transformed notation\n    \"\"\"\n    if \"-\" in iso:\n        iso = iso.split(\"-\")\n        return f\"{iso[1]}{iso[0]}\"\n    else:\n        index_to = None\n        for it, number in enumerate(iso):\n            try:\n                int(number)\n            except ValueError:\n                index_to = it\n                break\n        return f\"{iso[index_to:]}-{iso[:index_to]}\"\n</code></pre>"},{"location":"latex/#rttools.latex.ratio_iso","title":"<code>ratio_iso(iso1, iso2)</code>","text":"<p>Return LaTeX formatted string for ratio of two isotopes.</p> <p>Parameters:</p> Name Type Description Default <code>iso1</code> <code>str</code> <p>Nominator isotope, e.g., \"Si-30\"</p> required <code>iso2</code> <code>str</code> <p>Denominator isotope, e.g., \"Si-28\"</p> required <p>Returns:</p> Type Description <code>str</code> <p>LaTeX formatted label for isototope ratio.</p> Source code in <code>src/rttools/latex.py</code> <pre><code>def ratio_iso(iso1: str, iso2: str) -&gt; str:\n    \"\"\"Return LaTeX formatted string for ratio of two isotopes.\n\n    :param iso1: Nominator isotope, e.g., \"Si-30\"\n    :type iso1: str\n    :param iso2: Denominator isotope, e.g., \"Si-28\"\n\n    :return: LaTeX formatted label for isototope ratio.\n    :rtype: str\n    \"\"\"\n    ele1, aa1 = split_iso(iso1)\n    ele2, aa2 = split_iso(iso2)\n    ret_val = f\"${{^{{{aa1}}}}}\\\\mathrm{{{ele1}}}/{{^{{{aa2}}}}}\\\\mathrm{{{ele2}}}$\"\n    return ret_val\n</code></pre>"},{"location":"latex/#rttools.latex.split_iso","title":"<code>split_iso(iso)</code>","text":"<p>Split isotope string into element name and mass number.</p> <p>Parameters:</p> Name Type Description Default <code>iso</code> <code>str</code> <p>Isotope name, e.g., \"Si-28\"</p> required <p>Returns:</p> Type Description <code>Tuple[str, Union[int, str]]</code> <p>Isotope name, mass number (as int if possible)</p> Source code in <code>src/rttools/latex.py</code> <pre><code>def split_iso(iso: str) -&gt; Tuple[str, Union[int, str]]:\n    \"\"\"Split isotope string into element name and mass number.\n\n    :param iso: Isotope name, e.g., \"Si-28\"\n    :type iso: str\n\n    :return: Isotope name, mass number (as int if possible)\n    \"\"\"\n    # transform to correct format if necessary\n    if \"-\" not in iso:\n        iso = iso_transformer(iso)\n\n    ele, aa = iso.split(\"-\")\n    try:\n        aa = int(aa)\n    except ValueError:\n        pass\n    return ele, aa\n</code></pre>"},{"location":"peirce/","title":"Pierce's criterion","text":"<p>Run Peirce's criterion to reject data.</p> <p>Implementation after Ross (2003) using calculation method for table from Wikipedia. Note that the table that Ross (2003) presents is for <code>R</code>, which is the square root of what <code>x**2</code> means in Gould (1855). Also, the first value of Ross (2003) for three observations, one doubtful value seems to off by a little bit. The rest of the table agrees well.</p> <p>To import:</p> <pre><code>from rttools imoprt peirce\n</code></pre>"},{"location":"peirce/#rttools.peirce.peirce_criterion","title":"<code>peirce_criterion(n_tot, n, m=1)</code>","text":"<p>Peirce's criterion</p> <p>Returns the threshold error deviation for outlier identification using Peirce's criterion based on Gould's methodology. This routine is heavily copied from Wikipedia</p> <p>Parameters:</p> Name Type Description Default <code>n_tot</code> <code>int</code> <p>Total number of observations.</p> required <code>n</code> <code>int</code> <p>Number of outliers to be removed.</p> required <code>m</code> <code>int</code> <p>Number of model unknowns, defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>float</code> <p>Error threshold <code>R</code> (Ross, 2003) / Square root of <code>x**2</code> (Gould, 1955)</p> Source code in <code>src/rttools/peirce.py</code> <pre><code>def peirce_criterion(n_tot: int, n: int, m: int = 1) -&gt; float:\n    \"\"\"Peirce's criterion\n\n    Returns the threshold error deviation for outlier identification\n    using Peirce's criterion based on Gould's methodology.\n    This routine is heavily copied from Wikipedia\n\n    :param n_tot: Total number of observations.\n    :param n: Number of outliers to be removed.\n    :param m: Number of model unknowns, defaults to 1.\n\n    :return: Error threshold `R` (Ross, 2003) / Square root of `x**2` (Gould, 1955)\n    \"\"\"\n    # Check number of observations:\n    if n_tot &gt; 1:\n        # Calculate Q (Nth root of Gould's equation B):\n        q_cap = (n ** (n / n_tot) * (n_tot - n) ** ((n_tot - n) / n_tot)) / n_tot\n\n        # Initialize R values (as floats)\n        r_new = 1.0\n        r_old = 0.0\n        #\n        # Start iteration to converge on R:\n        while abs(r_new - r_old) &gt; (n_tot * 2.0e-16):\n            # Calculate Lamda\n            # (1/(N-n)th root of Gould's equation A'):\n            ldiv = r_new**n\n            if ldiv == 0:\n                ldiv = 1.0e-6\n            lambda_g = ((q_cap**n_tot) / (ldiv)) ** (1.0 / (n_tot - n))\n            # Calculate x-squared (Gould's equation C):\n            x2 = 1.0 + (n_tot - m - n) / n * (1.0 - lambda_g**2.0)\n            # If x2 goes negative, return 0:\n            if x2 &lt; 0:\n                x2 = 0.0\n                r_old = r_new\n            else:\n                # Use x-squared to update R (Gould's equation D):\n                r_old = r_new\n                r_new = np.exp((x2 - 1) / 2.0) * special.erfc(\n                    np.sqrt(x2) / np.sqrt(2.0)\n                )\n    else:\n        x2 = 0.0\n    return np.sqrt(x2)\n</code></pre>"},{"location":"peirce/#rttools.peirce.reject_outliers","title":"<code>reject_outliers(data, m=1)</code>","text":"<p>Applies Peirce's criterion to reject outliers.</p> <p>Algorithm implmeneted as given by Ross (2003).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>All data points.</p> required <code>m</code> <code>int</code> <p>Number of model unknowns, defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Tuple[float, float, ndarray]</code> <p>New average and standard deviation, Array with the outliers.</p> Source code in <code>src/rttools/peirce.py</code> <pre><code>def reject_outliers(data: np.ndarray, m: int = 1) -&gt; Tuple[float, float, np.ndarray]:\n    \"\"\"Applies Peirce's criterion to reject outliers.\n\n    Algorithm implmeneted as given by Ross (2003).\n\n    :param data: All data points.\n    :param m: Number of model unknowns, defaults to 1.\n\n    :return: New average and standard deviation, Array with the outliers.\n    \"\"\"\n    data = np.array(data)  # just making sure it's a numpy array\n\n    avg = np.average(data)\n    std = np.std(data)\n    n_tot = len(data)\n\n    outliers = []\n    diffs = np.abs(data - avg)\n\n    for it in range(len(data)):  # check for every data point if it should be rejected\n        max_diff = diffs.max()\n        max_ind = diffs.argmax()\n\n        rejection_limit = peirce_criterion(n_tot, it + 1, m)\n        if max_diff &gt; rejection_limit * std:\n            outliers.append(data[max_ind])\n            # delete max from diffs and data\n            data = np.delete(data, max_ind)\n            diffs = np.delete(diffs, max_ind)\n        else:\n            break  # we are done rejecting\n\n    avg_new = float(np.average(data))\n    std_new = float(np.std(data))\n\n    return avg_new, std_new, np.array(outliers)\n</code></pre>"},{"location":"plot/","title":"Plot","text":"<p>Some tools to make plotting with MPL easier.</p> <p>Import as:</p> <pre><code>from rttools import plot\n</code></pre>"},{"location":"plot/#rttools.plot.corr_error_bars","title":"<code>corr_error_bars(ax, xdata, ydata, xerr, yerr, rho, linestyle='-', linewidth=0.5, marker='None', color='tab:blue', label=None, zorder=10, **kwargs)</code>","text":"<p>Plot correlated error bars on a given axes.</p> <p>Further arguments to specify plot can be passed as **kwargs, which will be passed to the <code>matplotlib.pyplot.plot</code> routine.</p> <p>Currently only tested with some Mo data from Stephan et al. (2019) and compared in Inkscape.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Matplotlib axes to plot on</p> required <code>xdata</code> <code>ndarray</code> <p>data for x values</p> required <code>ydata</code> <code>ndarray</code> <p>data for y values</p> required <code>xerr</code> <code>ndarray</code> <p>uncertainty for x values</p> required <code>yerr</code> <code>ndarray</code> <p>uncertainty for y values</p> required <code>rho</code> <code>ndarray</code> <p>correlation coefficient</p> required <code>linestyle</code> <code>str</code> <p>Matplotlib linestyle, defaults to '-'</p> <code>'-'</code> <code>linewidth</code> <code>float</code> <p>Width of the error bar line, defaults to 0.5</p> <code>0.5</code> <code>marker</code> <code>str</code> <p>Matplotlib Marker, defaults to 'None'. Note: These would be the end markers of the line, not a marker in the middle!</p> <code>'None'</code> <code>color</code> <code>str</code> <p>Matplotlib color, defaults to 'tab:blue'</p> <code>'tab:blue'</code> <code>label</code> <code>str</code> <p>Label for data, only used if marker is not None.</p> <code>None</code> <code>zorder</code> <code>int</code> <p>Some value to define order.</p> <code>10</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/rttools/plot.py</code> <pre><code>def corr_error_bars(\n    ax: mpl.axes.Axes,\n    xdata: np.ndarray,\n    ydata: np.ndarray,\n    xerr: np.ndarray,\n    yerr: np.ndarray,\n    rho: np.ndarray,\n    linestyle: str = \"-\",\n    linewidth: float = 0.5,\n    marker: str = \"None\",\n    color: str = \"tab:blue\",\n    label: str = None,\n    zorder: int = 10,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Plot correlated error bars on a given axes.\n\n    Further arguments to specify plot can be passed as **kwargs, which will be passed\n    to the `matplotlib.pyplot.plot` routine.\n\n    Currently only tested with some Mo data from Stephan et al. (2019) and compared\n    in Inkscape.\n\n    :param ax: Matplotlib axes to plot on\n    :param xdata: data for x values\n    :param ydata: data for y values\n    :param xerr: uncertainty for x values\n    :param yerr: uncertainty for y values\n    :param rho: correlation coefficient\n    :param linestyle: Matplotlib linestyle, defaults to '-'\n    :param linewidth: Width of the error bar line, defaults to 0.5\n    :param marker: Matplotlib Marker, defaults to 'None'. Note: These would be the end\n        markers of the line, not a marker in the middle!\n    :param color: Matplotlib color, defaults to 'tab:blue'\n    :param label: Label for data, only used if marker is not None.\n    :param zorder: Some value to define order.\n\n    :return: None\n    \"\"\"\n    # loop through all data points\n    for it, xpos in enumerate(xdata):\n        ypos = ydata[it]\n        # get sig_x, sig_y, and calculate sig_xy of correlation matrix\n        sig_x = xerr[it]\n        sig_y = yerr[it]\n        sig_xy = rho[it] * sig_x * sig_y\n        # trace and determinat of covariance matrix\n        tr_cov = sig_x**2 + sig_y**2\n        det_cov = sig_x**2 * sig_y**2 - sig_xy**2\n        # calculate the eigenvalues\n        lam1 = tr_cov / 2 + np.sqrt((tr_cov / 2) ** 2 - det_cov)\n        lam2 = tr_cov / 2 - np.sqrt((tr_cov / 2) ** 2 - det_cov)\n\n        # calculate the rotation of the error bars\n        if sig_xy == 0:\n            determinator = lam1 - sig_x**2.0\n            if np.isclose(determinator, 0):  # to check for numerical issues\n                phi_x = 0  # 0 divided by infinity\n            else:\n                phi_x = np.pi / 2  # not 0 divided by infinity\n        else:\n            phi_x = np.arctan((lam1 - sig_x**2) / sig_xy)\n        phi_y = phi_x + np.pi / 2\n\n        # calculate delta x and delta y for x error bar:\n        dx_x = np.sqrt(lam1) * np.cos(phi_x)\n        dy_x = np.sqrt(lam1) * np.sin(phi_x)\n        # for y error bar\n        dx_y = np.sqrt(lam2) * np.cos(phi_y)\n        dy_y = np.sqrt(lam2) * np.sin(phi_y)\n\n        # plot the data if marker is not None\n        if it &gt; 0:  # remove label\n            label = None\n        if marker is not None:\n            ax.plot(\n                xdata,\n                ydata,\n                marker=marker,\n                linestyle=\"None\",\n                color=color,\n                label=label,\n                zorder=zorder + 1,\n                **kwargs,\n            )\n\n        # plot the x error bar\n        xdat_x = [xpos - dx_x, xpos + dx_x]\n        ydat_x = [ypos - dy_x, ypos + dy_x]\n        ax.plot(\n            xdat_x,\n            ydat_x,\n            marker=\"None\",\n            linestyle=linestyle,\n            color=color,\n            linewidth=linewidth,\n            zorder=zorder,\n            **kwargs,\n        )\n\n        # plot the y error bar\n        xdat_y = [xpos - dx_y, xpos + dx_y]\n        ydat_y = [ypos - dy_y, ypos + dy_y]\n        ax.plot(\n            xdat_y,\n            ydat_y,\n            marker=\"None\",\n            linestyle=linestyle,\n            color=color,\n            linewidth=linewidth,\n            zorder=zorder,\n            **kwargs,\n        )\n</code></pre>"},{"location":"utils/","title":"Utilities","text":"<p>Helper functions and utilities to be used and re-used in multiple areas.</p> <p>Import as:</p> <pre><code>from rttools import utils\n</code></pre>"},{"location":"utils/#rttools.utils.assume_units","title":"<code>assume_units(value, unit)</code>","text":"<p>Take a vale with or without unit and return it with a unit.</p> <p>If a value is given without units, assume the given units. If the value is given with units, return it.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Value to be converted</p> required <code>unit</code> <code>Quantity</code> <p>Unit to be assumed</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Value with assumed units</p> Source code in <code>src/rttools/utils.py</code> <pre><code>def assume_units(value: Any, unit: ureg.Quantity) -&gt; Any:\n    \"\"\"Take a vale with or without unit and return it with a unit.\n\n    If a value is given without units, assume the given units.\n    If the value is given with units, return it.\n\n    :param value: Value to be converted\n    :param unit: Unit to be assumed\n\n    :return: Value with assumed units\n    \"\"\"\n    if isinstance(value, ureg.Quantity):\n        return value\n    else:\n        return value * unit\n</code></pre>"},{"location":"utils/#rttools.utils.kron_delta","title":"<code>kron_delta(ind1, ind2)</code>","text":"<p>Calculate Kronecker-delta for variables i,j.</p> <p>Compare two indexes and return 0 if the same, otherwise 1. If an ndarray is given, return an ndarray comparing each index individually.</p> <p>Parameters:</p> Name Type Description Default <code>ind1</code> <code>int, ndarray&lt;int&gt;</code> <p>Index(es)</p> required <code>ind2</code> <code>int, ndarray&lt;int&gt;</code> <p>Index(es)</p> required <p>Returns:</p> Type Description <code>int, ndarray&lt;int&gt;</code> <p>1 if ind 1 is identical to ind2, otherwise 0</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>The input indexes have different shape.</p> Source code in <code>src/rttools/utils.py</code> <pre><code>def kron_delta(ind1, ind2):\n    \"\"\"Calculate Kronecker-delta for variables i,j.\n\n    Compare two indexes and return 0 if the same, otherwise 1. If an ndarray is given,\n    return an ndarray comparing each index individually.\n\n    :param ind1: Index(es)\n    :type ind1: int, ndarray&lt;int&gt;\n    :param ind2: Index(es)\n    :type ind2: int, ndarray&lt;int&gt;\n\n    :return: 1 if ind 1 is identical to ind2, otherwise 0\n    :rtype: int, ndarray&lt;int&gt;\n\n    :raises ValueError: The input indexes have different shape.\n    \"\"\"\n    if np.shape(ind1) != np.shape(ind2):\n        raise ValueError(\"The inputs must have the same shape.\")\n\n    if np.shape(ind1) == ():  # don't have arrays\n        return 1 if ind1 == ind2 else 0\n    else:\n        ret_arr = np.zeros_like(ind1)\n        ret_arr[np.where(ind1 == ind2)] = 1\n        return ret_arr\n</code></pre>"},{"location":"utils/#rttools.utils.reduce_decimal","title":"<code>reduce_decimal(num, prec=2)</code>","text":"<p>Return a given number with precision or cut trailing zeros if possible.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>Any</code> <p>Number given, anything that can be turned into a decimal.</p> required <code>prec</code> <code>int</code> <p>given precision.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>Number with at most the given precision.</p> Source code in <code>src/rttools/utils.py</code> <pre><code>def reduce_decimal(num: Any, prec: int = 2) -&gt; str:\n    \"\"\"Return a given number with precision or cut trailing zeros if possible.\n\n    :param num: Number given, anything that can be turned into a decimal.\n    :param prec: given precision.\n\n    :return: Number with at most the given precision.\n    \"\"\"\n    dec = decimal.Decimal(f\"{num:.{prec}f}\").normalize()\n    return str(dec)\n</code></pre>"},{"location":"nucmod/fruity/","title":"FRUITY model handlers","text":"<p>Handler for FRUITY model files (from http://fruity.oa-teramo.inaf.it/).</p> <p>This module provides some functions to work with the FRUITY nucleosynthesis models.</p> <p>Import as:</p> <pre><code>from rttools.nucmod import fruity\n</code></pre>"},{"location":"nucmod/fruity/#rttools.nucmod.fruity.drop_a_z","title":"<code>drop_a_z(df)</code>","text":"<p>Drop columns for A and Z for a dataframe.</p> <p>Leaves only columns with compositions over from a FRUITY dataframe and removes columns labeled \"A\" and \"Z\". If these columns don't exist, no error will be raised.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>FRUITY dataframe with columns \"A\" and \"Z\" present.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>same dataframe with those vectors dropped.</p> Source code in <code>src/rttools/nucmod/fruity.py</code> <pre><code>def drop_a_z(df: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"Drop columns for A and Z for a dataframe.\n\n    Leaves only columns with compositions over from a FRUITY dataframe and removes\n    columns labeled \"A\" and \"Z\". If these columns don't exist, no error will be raised.\n\n    :param df: FRUITY dataframe with columns \"A\" and \"Z\" present.\n\n    :return: same dataframe with those vectors dropped.\n    \"\"\"\n    retval = df.copy()\n    columns = [\"A\", \"Z\"]\n    for col in columns:\n        try:\n            retval.drop(columns=[col], inplace=True)\n        except KeyError:\n            pass\n\n    return retval\n</code></pre>"},{"location":"nucmod/fruity/#rttools.nucmod.fruity.get_delta_isoratio","title":"<code>get_delta_isoratio(fname, iso1, iso2, norm_self=False)</code>","text":"<p>Take a FRUITY file and return delta values for one isotope ratio.</p> <p>Delta will be calculated with respect to current iniabu default database. The ratio is going to be iso1/iso2. Initial and first dredge up (FDU) columns are returned as well.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>Path</code> <p>FRUITY file name.</p> required <code>iso1</code> <code>str</code> <p>Nominator isotope, any <code>iniabu</code> isotope name accepted.</p> required <code>iso2</code> <code>str</code> <p>Denominator isotope, any <code>iniabu</code> isotope name accepted.</p> required <code>norm_self</code> <code>bool</code> <p>Norm to itself, i.e., to the initial composition instead of using standard database by <code>iniabu</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series with delta ratio of the two.</p> Source code in <code>src/rttools/nucmod/fruity.py</code> <pre><code>def get_delta_isoratio(\n    fname: Path, iso1: str, iso2: str, norm_self: bool = False\n) -&gt; pd.Series:\n    \"\"\"Take a FRUITY file and return delta values for one isotope ratio.\n\n    Delta will be calculated with respect to current iniabu default database. The ratio\n    is going to be iso1/iso2. Initial and first dredge up (FDU) columns are returned as\n    well.\n\n    :param fname: FRUITY file name.\n    :param iso1: Nominator isotope, any `iniabu` isotope name accepted.\n    :param iso2: Denominator isotope, any `iniabu` isotope name accepted.\n    :param norm_self: Norm to itself, i.e., to the initial composition instead of using\n        standard database by `iniabu`.\n\n    :return: Series with delta ratio of the two.\n    \"\"\"\n    iso1f = make_fruity_isoname(iso1)\n    iso2f = make_fruity_isoname(iso2)\n\n    data = drop_a_z(reader(fname))\n    ratios = data.loc[iso1f] / data.loc[iso2f]\n\n    if norm_self:\n        delta = (ratios / ratios.iloc[0] - 1.0) * 1000\n    else:\n        delta = ini.iso_delta(iso1, iso2, ratios)\n        # fixme: this should be handled correctly by iniabu, but is not\n        delta = pd.Series(delta, index=ratios.index)\n    return delta\n</code></pre>"},{"location":"nucmod/fruity/#rttools.nucmod.fruity.label_latex_mass","title":"<code>label_latex_mass(fname, prec=1)</code>","text":"<p>Create a LaTeX label for only mass.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Filename of data file.</p> required <code>prec</code> <code>int</code> <p>Precision of return value (at most).</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>LaTeX label.</p> Source code in <code>src/rttools/nucmod/fruity.py</code> <pre><code>def label_latex_mass(fname: str, prec: int = 1) -&gt; str:\n    \"\"\"Create a LaTeX label for only mass.\n\n    :param fname: Filename of data file.\n    :param prec: Precision of return value (at most).\n\n    :return: LaTeX label.\n    \"\"\"\n    m, _, _, _ = label_parser(fname)\n    return f\"${reduce_decimal(m, prec)}\\\\,M_{{\\\\odot}}$\"\n</code></pre>"},{"location":"nucmod/fruity/#rttools.nucmod.fruity.label_latex_mass_z","title":"<code>label_latex_mass_z(fname, prec=2)</code>","text":"<p>Create a LaTeX label for mass and metallicity.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Filename of data file.</p> required <code>prec</code> <code>int</code> <p>Precision of return value (at most).</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>LaTeX label.</p> Source code in <code>src/rttools/nucmod/fruity.py</code> <pre><code>def label_latex_mass_z(fname: str, prec: int = 2) -&gt; str:\n    \"\"\"Create a LaTeX label for mass and metallicity.\n\n    :param fname: Filename of data file.\n    :param prec: Precision of return value (at most).\n\n    :return: LaTeX label.\n    \"\"\"\n    m, z, _, _ = label_parser(fname)\n    return (\n        f\"${reduce_decimal(m, prec)}\\\\,M_{{\\\\odot}}$, \"\n        f\"${reduce_decimal(z, prec)}\\\\,Z_{{\\\\odot}}$\"\n    )\n</code></pre>"},{"location":"nucmod/fruity/#rttools.nucmod.fruity.label_latex_mass_z_pocket","title":"<code>label_latex_mass_z_pocket(fname, prec=2)</code>","text":"<p>Create a LaTeX label for mass and metallicity.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Filename of data file.</p> required <code>prec</code> <code>int</code> <p>Precision of return value (at most).</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>LaTeX label.</p> Source code in <code>src/rttools/nucmod/fruity.py</code> <pre><code>def label_latex_mass_z_pocket(fname: str, prec: int = 2) -&gt; str:\n    \"\"\"Create a LaTeX label for mass and metallicity.\n\n    :param fname: Filename of data file.\n    :param prec: Precision of return value (at most).\n\n    :return: LaTeX label.\n    \"\"\"\n    m, z, _, pocket = label_parser(fname)\n    return (\n        f\"${reduce_decimal(m, prec)}\\\\,M_{{\\\\odot}}$, \"\n        f\"${reduce_decimal(z, prec)}\\\\,Z_{{\\\\odot}}$, \"\n        f\"{pocket}\"\n    )\n</code></pre>"},{"location":"nucmod/fruity/#rttools.nucmod.fruity.label_latex_mass_z_pocket_rot","title":"<code>label_latex_mass_z_pocket_rot(fname, prec=2)</code>","text":"<p>Create a LaTeX label for mass and metallicity.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Filename of data file.</p> required <code>prec</code> <code>int</code> <p>Precision of return value (at most).</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>LaTeX label.</p> Source code in <code>src/rttools/nucmod/fruity.py</code> <pre><code>def label_latex_mass_z_pocket_rot(fname: str, prec: int = 2) -&gt; str:\n    \"\"\"Create a LaTeX label for mass and metallicity.\n\n    :param fname: Filename of data file.\n    :param prec: Precision of return value (at most).\n\n    :return: LaTeX label.\n    \"\"\"\n    m, z, rot, pocket = label_parser(fname)\n    return (\n        f\"${reduce_decimal(m, prec)}\\\\,M_{{\\\\odot}}$, \"\n        f\"${reduce_decimal(z, prec)}\\\\,Z_{{\\\\odot}}$, \"\n        f\"{pocket}, \"\n        f\"IRV: ${reduce_decimal(rot, prec)}\\\\,$km\\\\,s$^{{-1}}$\"\n    )\n</code></pre>"},{"location":"nucmod/fruity/#rttools.nucmod.fruity.label_parser","title":"<code>label_parser(fname)</code>","text":"<p>Label parser for FRUITY models.</p> <p>Take a FRUITY filename and return various parameters as numbers.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>Union[str, Path]</code> <p>File name of the FRUITY file.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float, float, str]</code> <p>Mass (M_sun), Metallicity (Z_sun), Rotation (km/s), C13 pocket (std / ext)</p> Source code in <code>src/rttools/nucmod/fruity.py</code> <pre><code>def label_parser(fname: Union[str, Path]) -&gt; Tuple[float, float, float, str]:\n    \"\"\"Label parser for FRUITY models.\n\n    Take a FRUITY filename and return various parameters as numbers.\n\n    :param fname: File name of the FRUITY file.\n\n    :return: Mass (M_sun), Metallicity (Z_sun), Rotation (km/s), C13 pocket (std / ext)\n    \"\"\"\n    if isinstance(fname, Path):\n        fname = str(fname.name)\n\n    # remove 'isotopi_'\n    fname = fname.replace(\"isotopi_\", \"\")\n\n    # now break by '_' and use first two\n    fname = fname.split(\"_\")[:2]\n\n    # mass and metallicity\n    z_start = fname[0].find(\"z\")\n    mass = float(fname[0][1:z_start].replace(\"p\", \".\"))\n    z = fname[0][z_start + 1 :].replace(\"m\", \"e-\")\n    if z == \"sun\":\n        z = 1\n    else:\n        z = float(z) / 1.4e-2\n\n    # pocket and rotation\n    if fname[1][0] == \"T\":\n        pocket = \"ext\"\n    else:\n        pocket = \"std\"\n    rot = float(fname[1][1:])\n    return mass, z, rot, pocket\n</code></pre>"},{"location":"nucmod/fruity/#rttools.nucmod.fruity.make_fruity_isoname","title":"<code>make_fruity_isoname(iso)</code>","text":"<p>Pass an isotope through <code>iniabu</code> and then parse a FRUITY isotope name.</p> <p>Parameters:</p> Name Type Description Default <code>iso</code> <code>str</code> <p>Isotope, e.g., \"28Si\", \"Si-28\", \"Si28\"</p> required <p>Returns:</p> Type Description <code>str</code> <p>FRUITY name, e.g., \"Si28\"</p> Source code in <code>src/rttools/nucmod/fruity.py</code> <pre><code>def make_fruity_isoname(iso: str) -&gt; str:\n    \"\"\"Pass an isotope through `iniabu` and then parse a FRUITY isotope name.\n\n    :param iso: Isotope, e.g., \"28Si\", \"Si-28\", \"Si28\"\n\n    :return: FRUITY name, e.g., \"Si28\"\n    \"\"\"\n    iso = ini.iso[iso].name.split(\"-\")\n    iso_fruity = iso[0] + iso[1][-2:]\n    return iso_fruity\n</code></pre>"},{"location":"nucmod/fruity/#rttools.nucmod.fruity.plot_mod","title":"<code>plot_mod(ax, fname, xisos, yisos, norm_self=False, marker='o', color='tab:blue', label=None, linestyle='-', **kwargs)</code>","text":"<p>Plot FRUITY Model curve onto a plot.</p> <p>Note that **kwargs are passed along to both plotting routines. For C/O &lt; 1, the marker is set to 'None'.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Matplotlib axis to plot on.</p> required <code>fname</code> <code>Path</code> <p>Filename of model data file</p> required <code>xisos</code> <code>Tuple[str, str]</code> <p>Tuple of two isotopes (nominator, denominator) for x axis.</p> required <code>yisos</code> <code>Tuple[str, str]</code> <p>Tuple of two isotopes (nominator, denominator) for y axis.</p> required <code>norm_self</code> <code>bool</code> <p>Norm to itself, i.e., to the initial composition instead of using standard database by <code>iniabu</code>.</p> <code>False</code> <code>marker</code> <code>str</code> <p>Marker of the plot, defaults to 'o'</p> <code>'o'</code> <code>color</code> <code>str</code> <p>Color of the plot, defaults to 'tab:blue'</p> <code>'tab:blue'</code> <code>linestyle</code> <code>str</code> <p>Linestyle of the plot, defaults to '-'</p> <code>'-'</code> <p>Returns:</p> Type Description <code>None</code> <p>Nothing</p> Source code in <code>src/rttools/nucmod/fruity.py</code> <pre><code>def plot_mod(\n    ax: plt.Axes,\n    fname: Path,\n    xisos: Tuple[str, str],\n    yisos: Tuple[str, str],\n    norm_self: bool = False,\n    marker: str = \"o\",\n    color: str = \"tab:blue\",\n    label=None,\n    linestyle: str = \"-\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Plot FRUITY Model curve onto a plot.\n\n    Note that **kwargs are passed along to both plotting routines. For C/O &lt; 1, the\n    marker is set to 'None'.\n\n    :param ax: Matplotlib axis to plot on.\n    :param fname: Filename of model data file\n    :param xisos: Tuple of two isotopes (nominator, denominator) for x axis.\n    :param yisos: Tuple of two isotopes (nominator, denominator) for y axis.\n    :param norm_self: Norm to itself, i.e., to the initial composition instead of using\n        standard database by `iniabu`.\n    :param marker: Marker of the plot, defaults to 'o'\n    :param color: Color of the plot, defaults to 'tab:blue'\n    :param linestyle: Linestyle of the plot, defaults to '-'\n\n    :return: Nothing\n    \"\"\"\n    drop_cols = [\"INI\", \"FDU\"]\n    xdat_all = get_delta_isoratio(fname, xisos[0], xisos[1], norm_self=norm_self).drop(\n        columns=drop_cols\n    )\n    ydat_all = get_delta_isoratio(fname, yisos[0], yisos[1], norm_self=norm_self).drop(\n        columns=drop_cols\n    )\n    co_ratio = drop_a_z(reader(fname).loc[\"CO_ratio\"]).drop(columns=drop_cols)\n\n    crich_mask = co_ratio &gt;= 1\n\n    # plot all\n    ax.plot(\n        xdat_all, ydat_all, marker=\"None\", linestyle=linestyle, color=color, **kwargs\n    )\n    # plot c-rich\n    ax.plot(\n        xdat_all[crich_mask],\n        ydat_all[crich_mask],\n        marker=marker,\n        color=color,\n        linestyle=\"None\",\n        label=label,\n        **kwargs,\n    )\n</code></pre>"},{"location":"nucmod/fruity/#rttools.nucmod.fruity.reader","title":"<code>reader(fname)</code>","text":"<p>Read in a FRUITY file and return values as DataFrame.</p> Source code in <code>src/rttools/nucmod/fruity.py</code> <pre><code>def reader(fname: Path) -&gt; pd.DataFrame:\n    \"\"\"Read in a FRUITY file and return values as DataFrame.\"\"\"\n    data = pd.read_csv(fname, sep=r\" \", index_col=0, skipinitialspace=True)\n\n    # drop nan columns\n    data = data.dropna(axis=1, how=\"all\")\n\n    # set the column labels straight\n    col_labels = [\"A\", \"Z\", \"INI\", \"FDU\"]  # the first four, isotope is index\n    co_ratio_cols = [\"INI\", \"FDU\"]  # calculate CO ratios for these plus TDUs\n    for it in range(data.shape[1] - len(col_labels)):\n        tdu = f\"TDU_{it+1}\"\n        col_labels.append(tdu)\n        co_ratio_cols.append(tdu)\n    data.columns = col_labels\n\n    # create a new series with C/O ratio called CO_ratio\n    co_ratio = data.loc[[\"C12\", \"C13\"], co_ratio_cols].sum(axis=0) / data.loc[\n        [\"O16\", \"O17\", \"O18\"], co_ratio_cols\n    ].sum(axis=0)\n\n    data.loc[\"CO_ratio\"] = co_ratio\n\n    return data\n</code></pre>"},{"location":"nucmod/lugaro/","title":"Lugaro nucleosynthesis models","text":"<p>Model reader for Maria Lugaro's AGB star files.</p> <p>Import as:</p> <pre><code>from rttools.nucmod import lugaro\n</code></pre>"},{"location":"nucmod/lugaro/#rttools.nucmod.lugaro.label_latex_mass","title":"<code>label_latex_mass(fname, prec=1)</code>","text":"<p>Create a LaTeX label for only mass.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Filename of data file.</p> required <code>prec</code> <code>int</code> <p>Precision of return value (at most).</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>LaTeX label.</p> Source code in <code>src/rttools/nucmod/lugaro.py</code> <pre><code>def label_latex_mass(fname: str, prec: int = 1) -&gt; str:\n    \"\"\"Create a LaTeX label for only mass.\n\n    :param fname: Filename of data file.\n    :param prec: Precision of return value (at most).\n\n    :return: LaTeX label.\n    \"\"\"\n    m, _, _, _ = label_parser(fname)\n    return f\"${reduce_decimal(m, prec)}\\\\,M_{{\\\\odot}}$\"\n</code></pre>"},{"location":"nucmod/lugaro/#rttools.nucmod.lugaro.label_latex_mass_z","title":"<code>label_latex_mass_z(fname, prec=2)</code>","text":"<p>Create a LaTeX label for mass and metallicity.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Filename of data file.</p> required <code>prec</code> <code>int</code> <p>Precision of return value (at most).</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>LaTeX label.</p> Source code in <code>src/rttools/nucmod/lugaro.py</code> <pre><code>def label_latex_mass_z(fname: str, prec: int = 2) -&gt; str:\n    \"\"\"Create a LaTeX label for mass and metallicity.\n\n    :param fname: Filename of data file.\n    :param prec: Precision of return value (at most).\n\n    :return: LaTeX label.\n    \"\"\"\n    m, z, _, _ = label_parser(fname)\n    return (\n        f\"${reduce_decimal(m, prec)}\\\\,M_{{\\\\odot}}$, \"\n        f\"${reduce_decimal(z, prec)}\\\\,Z_{{\\\\odot}}$\"\n    )\n</code></pre>"},{"location":"nucmod/lugaro/#rttools.nucmod.lugaro.label_latex_mass_z_pmz","title":"<code>label_latex_mass_z_pmz(fname, prec=2)</code>","text":"<p>Create a LaTeX label for mass, metallicity, and PMZ.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Filename of data file.</p> required <code>prec</code> <code>int</code> <p>Precision of return value (at most).</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>LaTeX label.</p> Source code in <code>src/rttools/nucmod/lugaro.py</code> <pre><code>def label_latex_mass_z_pmz(fname: str, prec: int = 2) -&gt; str:\n    \"\"\"Create a LaTeX label for mass, metallicity, and PMZ.\n\n    :param fname: Filename of data file.\n    :param prec: Precision of return value (at most).\n\n    :return: LaTeX label.\n    \"\"\"\n    m, z, pmz, st = label_parser(fname)\n\n    return (\n        f\"${reduce_decimal(m, prec)}\\\\,M_{{\\\\odot}}$, \"\n        f\"${reduce_decimal(z, prec)}\\\\,Z_{{\\\\odot}}$, \"\n        f\"PMZ: {exp_notation(pmz, prec)}$\\\\,M_{{\\\\odot}}$\"\n    )\n</code></pre>"},{"location":"nucmod/lugaro/#rttools.nucmod.lugaro.label_parser","title":"<code>label_parser(fname)</code>","text":"<p>Parse a filename and return properties of star.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>File name (with or without \".dat\")</p> required <p>Returns:</p> Type Description <code>Tuple[float, float, float, bool]</code> <p>Mass (M_sun), Metallicity (Z_sun), PMZ, st-case</p> Source code in <code>src/rttools/nucmod/lugaro.py</code> <pre><code>def label_parser(fname: str) -&gt; Tuple[float, float, float, bool]:\n    \"\"\"Parse a filename and return properties of star.\n\n    :param fname: File name (with or without \".dat\")\n\n    :return: Mass (M_sun), Metallicity (Z_sun), PMZ, st-case\n    \"\"\"\n    if isinstance(fname, Path):\n        fname = str(fname.name)\n\n    mass_start = fname.find(\"m\")\n    z_start = fname.find(\"z\", mass_start)\n    pmz_start = fname.find(\"pmz\", z_start)\n\n    st = False\n    if \"ST\" in fname or \"st\" in fname:\n        st = True\n\n    # remove .dat and ST\n    fname = fname.replace(\".dat\", \"\")\n    fname = fname.replace(\"ST\", \"\")\n    fname = fname.replace(\"st\", \"\")\n\n    # parse data\n    mass = float(fname[mass_start + 1 : z_start].replace(\"p\", \".\"))\n    z = fname[z_start + 1 : pmz_start]\n    if len(z) == 2:\n        z = f\"{z}0\"\n    z = float(z) / 14\n    pmz = float(fname[pmz_start + 3 :].replace(\"m\", \"e-\"))\n\n    return mass, z, pmz, st\n</code></pre>"},{"location":"nucmod/lugaro/#rttools.nucmod.lugaro.plot_mod","title":"<code>plot_mod(ax, fname, xdat_col, ydat_col, co_ratio_col=0, marker='o', color='tab:blue', label=None, linestyle='-', **kwargs)</code>","text":"<p>Plot Lugaro Model curve onto a plot.</p> <p>Note that **kwargs are passed along to both plotting routines. For C/O &lt; 1, the marker is set to 'None'.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Matplotlib axis to plot on.</p> required <code>fname</code> <code>Path</code> <p>Filename of model data file</p> required <code>xdat_col</code> <code>int</code> <p>Number of column to plot on x-axis</p> required <code>ydat_col</code> <code>int</code> <p>Number of column to plot on y-axis</p> required <code>co_ratio_col</code> <code>int</code> <p>Number of column for CO ratio (defaults to 0)</p> <code>0</code> <code>marker</code> <code>str</code> <p>Marker of the plot, defaults to 'o'</p> <code>'o'</code> <code>color</code> <code>str</code> <p>Color of the plot, defaults to 'tab:blue'</p> <code>'tab:blue'</code> <code>linestyle</code> <code>str</code> <p>Linestyle of the plot, defaults to '-'</p> <code>'-'</code> <p>Returns:</p> Type Description <code>None</code> <p>Nothing</p> Source code in <code>src/rttools/nucmod/lugaro.py</code> <pre><code>def plot_mod(\n    ax: plt.Axes,\n    fname: Path,\n    xdat_col: int,\n    ydat_col: int,\n    co_ratio_col: int = 0,\n    marker: str = \"o\",\n    color: str = \"tab:blue\",\n    label=None,\n    linestyle: str = \"-\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Plot Lugaro Model curve onto a plot.\n\n    Note that **kwargs are passed along to both plotting routines. For C/O &lt; 1, the\n    marker is set to 'None'.\n\n    :param ax: Matplotlib axis to plot on.\n    :param fname: Filename of model data file\n    :param xdat_col: Number of column to plot on x-axis\n    :param ydat_col: Number of column to plot on y-axis\n    :param co_ratio_col: Number of column for CO ratio (defaults to 0)\n    :param marker: Marker of the plot, defaults to 'o'\n    :param color: Color of the plot, defaults to 'tab:blue'\n    :param linestyle: Linestyle of the plot, defaults to '-'\n\n    :return: Nothing\n    \"\"\"\n    data = reader(fname)\n\n    xdat_all = data[f\"{xdat_col}\"]\n    ydat_all = data[f\"{ydat_col}\"]\n    co_ratio = data[f\"{co_ratio_col}\"]\n\n    crich_mask = co_ratio &gt;= 1\n\n    # plot all\n    ax.plot(\n        xdat_all, ydat_all, marker=\"None\", linestyle=linestyle, color=color, **kwargs\n    )\n    # plot c-rich\n    ax.plot(\n        xdat_all[crich_mask],\n        ydat_all[crich_mask],\n        marker=marker,\n        color=color,\n        linestyle=\"None\",\n        label=label,\n        **kwargs,\n    )\n</code></pre>"},{"location":"nucmod/lugaro/#rttools.nucmod.lugaro.reader","title":"<code>reader(fname, cols=None)</code>","text":"<p>Read a Lugaro ABG star file and return it.</p> <p>In these files, the first column is generally the model number. Subsequent columns are labeled with integers, starting at zero. In my experience, column 0 is generally the C/O ratio. Subsequent columns are delta-values of specific isotope ratios.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>Path</code> <p>Filename of file to read</p> required <code>cols</code> <code>List[str]</code> <p>Optional, headers for the columns starting with integers.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Data Frame of the whole file, with columns as headers if given.</p> Source code in <code>src/rttools/nucmod/lugaro.py</code> <pre><code>def reader(fname: Path, cols: List[str] = None) -&gt; pd.DataFrame:\n    \"\"\"Read a Lugaro ABG star file and return it.\n\n    In these files, the first column is generally the model number. Subsequent columns\n    are labeled with integers, starting at zero.\n    In my experience, column 0 is generally the C/O ratio. Subsequent columns are\n    delta-values of specific isotope ratios.\n\n    :param fname: Filename of file to read\n    :param cols: Optional, headers for the columns starting with integers.\n\n    :return: Data Frame of the whole file, with columns as headers if given.\n    \"\"\"\n    data = pd.read_csv(fname, sep=\"\\t\")\n\n    if cols is not None:\n        cols_new = cols.copy()\n        cols_new.insert(0, \"model number\")\n        data.columns = cols_new\n\n    return data\n</code></pre>"},{"location":"rims/converters/","title":"RIMS converter tools","text":"<p>Converters for RIMS work.</p> <p>This module contains converters that are conventient when working with RIMS data, etc.</p> <p>Import as:</p> <pre><code>from rttools.rims import converters\n</code></pre>"},{"location":"rims/converters/#rttools.rims.converters.power_after_window","title":"<code>power_after_window(power, passes=1, transmittance=0.96)</code>","text":"<p>Calculate power after a laser passes through a window.</p> <p>Going through a window will reduce the power by transmittance**2 per pass. This is because of the following:</p> <pre><code>        S1      S2\nlaser   |       |\n--------|-------|--------\n        |       |\n         window\n</code></pre> <p>As the simplified drawing shows, the window has an entrance and an exit surface, at which the laser loses in each case <code>transmittance</code> of its total power. Surfaces are labeled S1 and S2.</p> <p>Parameters:</p> Name Type Description Default <code>power</code> <code>Any</code> <p>Initial power</p> required <code>passes</code> <code>int</code> <p>Number of passes through a window.</p> <code>1</code> <code>transmittance</code> <code>float</code> <p>Transmittance of the window, defaults to 0.96.</p> <code>0.96</code> <p>Returns:</p> Type Description <code>Any</code> <p>Power after the <code>passes</code> passes through the window.</p> Source code in <code>src/rttools/rims/converters.py</code> <pre><code>def power_after_window(power: Any, passes: int = 1, transmittance: float = 0.96) -&gt; Any:\n    \"\"\"Calculate power after a laser passes through a window.\n\n    Going through a window will reduce the power by transmittance**2 per pass.\n    This is because of the following:\n\n                S1      S2\n        laser   |       |\n        --------|-------|--------\n                |       |\n                 window\n\n    As the simplified drawing shows, the window has an entrance and an exit surface,\n    at which the laser loses in each case `transmittance` of its total power.\n    Surfaces are labeled S1 and S2.\n\n    :param power: Initial power\n    :param passes: Number of passes through a window.\n    :param transmittance: Transmittance of the window, defaults to 0.96.\n\n    :return: Power after the `passes` passes through the window.\n    \"\"\"\n    return power * transmittance ** (2 * passes)\n</code></pre>"},{"location":"rims/converters/#rttools.rims.converters.power_to_irradiance","title":"<code>power_to_irradiance(power, rep_rate, beam_size, beam_dt)</code>","text":"<p>Calculate irradiance from beam power and characteristics.</p> <p>Take the users beam parameters and calculate the irradiance for saturation curves. All parameters can be passed as floats or as pint quantities. Standard units as given below are assumed if no quantities are provided.</p> <p>:Example:</p> <pre><code>&gt;&gt;&gt; power = 811 * ureg.mW\n&gt;&gt;&gt; rep_rate = 1000 * ureg.Hz\n&gt;&gt;&gt; beam_size = (1.5, 1.6) * ureg.mm\n&gt;&gt;&gt; beam_dt = 1.355e-8 * ureg.s\n&gt;&gt;&gt; power_to_irradiance(power, rep_rate, beam_size, beam_dt)\n&lt;Quantity(3175268.36, 'watt / centimeter ** 2')&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>power</code> <code>Union[float, Quantity]</code> <p>Beam power (defaults to mW)</p> required <code>rep_rate</code> <code>Union[float, Quantity]</code> <p>Repetition rate of laser (defaults to Hz)</p> required <code>beam_size</code> <code>Union[list, tuple, ArrayLike, Union[float, Quantity]]</code> <p>Tuple of beam diameters or float of diameters if equal (defaults to mm for individual entries).</p> required <code>beam_dt</code> <code>Union[float, Quantity]</code> <p>Pulse width (defaults to ns)</p> required <p>Returns:</p> Type Description <code>Quantity</code> <p>Unitful irradiance (W/cm^2)</p> Source code in <code>src/rttools/rims/converters.py</code> <pre><code>def power_to_irradiance(\n    power: Union[float, ureg.Quantity],\n    rep_rate: Union[float, ureg.Quantity],\n    beam_size: Union[list, tuple, ArrayLike, Union[float, ureg.Quantity]],\n    beam_dt: Union[float, ureg.Quantity],\n) -&gt; ureg.Quantity:\n    \"\"\"Calculate irradiance from beam power and characteristics.\n\n    Take the users beam parameters and calculate the irradiance for saturation curves.\n    All parameters can be passed as floats or as pint quantities. Standard units as\n    given below are assumed if no quantities are provided.\n\n    :param power: Beam power (defaults to mW)\n    :param rep_rate: Repetition rate of laser (defaults to Hz)\n    :param beam_size: Tuple of beam diameters or float of diameters if equal\n        (defaults to mm for individual entries).\n    :param beam_dt: Pulse width (defaults to ns)\n\n    :return: Unitful irradiance (W/cm^2)\n\n    :Example:\n\n        &gt;&gt;&gt; power = 811 * ureg.mW\n        &gt;&gt;&gt; rep_rate = 1000 * ureg.Hz\n        &gt;&gt;&gt; beam_size = (1.5, 1.6) * ureg.mm\n        &gt;&gt;&gt; beam_dt = 1.355e-8 * ureg.s\n        &gt;&gt;&gt; power_to_irradiance(power, rep_rate, beam_size, beam_dt)\n        &lt;Quantity(3175268.36, 'watt / centimeter ** 2')&gt;\n\n    \"\"\"\n    power = ut.assume_units(power, ureg.mW)\n    rep_rate = ut.assume_units(rep_rate, ureg.Hz)\n    try:\n        _ = beam_size[1]  # check if iterable\n        beam_size = ut.assume_units(beam_size, ureg.mm)\n    except TypeError:  # not iterable\n        if isinstance(beam_size, ureg.Quantity):\n            beam_size = beam_size.to(ureg.mm).magnitude\n        beam_size = ut.assume_units([beam_size, beam_size], ureg.mm)\n    beam_dt = ut.assume_units(beam_dt, ureg.ns)\n\n    beam_area = beam_size[0] / 2 * beam_size[1] / 2 * np.pi\n\n    irr = power / (rep_rate * beam_area * beam_dt)\n    return irr.to(ureg.W / ureg.cm**2)\n</code></pre>"},{"location":"rims/saturation_curves/","title":"Saturation curve plotter","text":"<p>Plot some good-looking saturation curves from measurements.</p> <p>Import as:</p> <pre><code>from rttools.rims import saturation_curve\n</code></pre>"},{"location":"rims/saturation_curves/#rttools.rims.saturation_curve.saturation_curve","title":"<code>saturation_curve(xdata, ydata, xunit=None, yunit=None, xlabel=None, ylabel='Signal', fit=True, darkmode=False, title=None)</code>","text":"<p>Plot a saturation curve from data.</p> <p>If fitting is desired, a Letokhov saturation curve is fitted to the data and plotted. The fit parameters are printed on the plot. The fit is done with the <code>scipy.optimize.curve_fit</code> function and only considers uncertainties in the y-axis data, if given. The fit function is <code>n = ni + nmax * (1 - exp(-x / isat))</code>.</p> <p>Parameters:</p> Name Type Description Default <code>xdata</code> <code>ndarray</code> <p>x-axis data. Can contain two columns for error bars.</p> required <code>ydata</code> <code>ndarray</code> <p>y-axis data. Can contain two columns for error bars.</p> required <code>xunit</code> <code>Union[Quantity, str]</code> <p>Unit for x-axis data. If <code>xdata</code> is unitful, this is ignored.</p> <code>None</code> <code>yunit</code> <code>Union[Quantity, str]</code> <p>Unit for y-axis data. If <code>ydata</code> is unitful, this is ignored.</p> <code>None</code> <code>xlabel</code> <code>str</code> <p>Label for x-axis. If None, try to infer from xunit. Infers \"Power\" if xunit is in W or \"Irradiance\" if xunit is in W/cm^2.</p> <code>None</code> <code>fit</code> <code>bool</code> <p>If True, fit a Letokhov saturation curve to the data, plot it, and mark up with fit parameters.</p> <code>True</code> <code>darkmode</code> <code>bool</code> <p>If True, use darkmode for the plot.</p> <code>False</code> <code>title</code> <code>str</code> <p>Title for the plot</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Matplotlib axis</p> Source code in <code>src/rttools/rims/saturation_curve.py</code> <pre><code>def saturation_curve(\n    xdata: np.ndarray,\n    ydata: np.ndarray,\n    xunit: Union[ureg.Quantity, str] = None,\n    yunit: Union[ureg.Quantity, str] = None,\n    xlabel: str = None,\n    ylabel: str = \"Signal\",\n    fit: bool = True,\n    darkmode: bool = False,\n    title: str = None,\n) -&gt; plt.Figure:\n    \"\"\"Plot a saturation curve from data.\n\n    If fitting is desired, a Letokhov saturation curve is fitted to the data and plotted.\n    The fit parameters are printed on the plot.\n    The fit is done with the `scipy.optimize.curve_fit` function and only considers\n    uncertainties in the y-axis data, if given.\n    The fit function is `n = ni + nmax * (1 - exp(-x / isat))`.\n\n    :param xdata: x-axis data. Can contain two columns for error bars.\n    :param ydata: y-axis data. Can contain two columns for error bars.\n    :param xunit: Unit for x-axis data. If `xdata` is unitful, this is ignored.\n    :param yunit: Unit for y-axis data. If `ydata` is unitful, this is ignored.\n    :param xlabel: Label for x-axis. If None, try to infer from xunit.\n        Infers \"Power\" if xunit is in W or \"Irradiance\" if xunit is in W/cm^2.\n    :param fit: If True, fit a Letokhov saturation curve to the data, plot it,\n        and mark up with fit parameters.\n    :param darkmode: If True, use darkmode for the plot.\n    :param title: Title for the plot\n\n    :return: Matplotlib axis\n    \"\"\"\n    if isinstance(xdata, ureg.Quantity):\n        xunit = xdata.units\n        xdata = xdata.magnitude\n    elif isinstance(xunit, str):\n        xunit = ureg.Unit(xunit)\n\n    if isinstance(ydata, ureg.Quantity):\n        yunit = ydata.units\n        ydata = ydata.magnitude\n    elif isinstance(yunit, str):\n        yunit = ureg.Unit(yunit)\n\n    # latex units if not none\n    xunit_ltx = None\n    yunit_ltx = None\n    if xunit is not None:\n        xunit_ltx = f\"{xunit:P~}\"\n    if yunit is not None:\n        yunit_ltx = f\"{yunit:P~}\"\n\n    # infer xlabel if not given\n    if xunit is not None:\n        if xlabel is None:\n            if xunit.compatible_units() == ureg.W.compatible_units():\n                xlabel = \"Power\"\n            elif xunit.compatible_units() == (ureg.W / ureg.cm**2).compatible_units():\n                xlabel = \"Irradiance\"\n\n    # split xdata and ydata into xdata, xerr and ydata, yerr\n    if xdata.ndim == 2:\n        xerr = xdata[1]\n        xdata = xdata[0]\n    else:\n        xerr = None\n    if ydata.ndim == 2:\n        yerr = ydata[1]\n        ydata = ydata[0]\n    else:\n        yerr = None\n\n    if darkmode:\n        plt.style.use(\"dark_background\")\n        col_blue = \"lightblue\"\n        col_red = \"lightsalmon\"\n    else:\n        plt.style.use(\"default\")\n        col_blue = \"tab:blue\"\n        col_red = \"darkred\"\n\n    # create the figure\n    fig, ax = plt.subplots(1, 1)\n\n    # plot the data\n    ax.errorbar(\n        xdata,\n        ydata,\n        xerr=xerr,\n        yerr=yerr,\n        marker=\"o\",\n        label=\"Data\",\n        linestyle=\"None\",\n        linewidth=0.5,\n        color=col_blue,\n    )\n\n    # Axes labels\n    if xlabel:\n        if xunit_ltx:\n            ax.set_xlabel(f\"{xlabel} ({xunit_ltx})\")\n        else:\n            ax.set_xlabel(f\"{xlabel}\")\n\n    if ylabel:\n        if yunit_ltx is not None:\n            ax.set_ylabel(f\"{ylabel} ({yunit_ltx})\")\n        else:\n            ax.set_ylabel(f\"{ylabel} (arb)\")\n\n    # fit a curve if desired\n    if fit:\n        # take an initial guess from the data\n        initial_guess = [0, 1, np.max(xdata) / 2]\n\n        popt, pcov = curve_fit(\n            _letokhov,\n            xdata,\n            ydata,\n            p0=initial_guess,\n            sigma=yerr,\n        )\n        ni, nmax, isat = popt\n        xfit = np.linspace(xdata.min(), xdata.max(), 1000)\n        yfit = _letokhov(xfit, ni, nmax, isat)\n\n        ax.plot(xfit, yfit, label=\"Fit\", color=col_red, linestyle=\"-\")\n        ax.legend(loc=\"upper left\", facecolor=\"None\")\n\n        fit_string = \"Fit parameters:\\n\"\n        fit_string += (\n            f\"I$_\\\\mathrm{{sat}}$ = {latex.exp_notation(isat, 2)} {xunit_ltx}\\n\"\n        )\n        fit_string += f\"N$_\\\\mathrm{{max}}$ = {nmax:.2f}\"\n\n        ax.text(\n            0.96,\n            0.05,\n            fit_string,\n            color=col_red,\n            alpha=1,\n            transform=ax.transAxes,\n            va=\"bottom\",\n            ha=\"right\",\n            ma=\"left\",\n            bbox=dict(boxstyle=\"round\", facecolor=\"None\", alpha=0.7, edgecolor=col_red),\n        )\n\n    if title:\n        ax.set_title(title)\n\n    fig.tight_layout()\n    return fig\n</code></pre>"}]}